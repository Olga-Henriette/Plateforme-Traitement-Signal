// =========================================================================
// PROCESS_IMAGE.SCI - Amélioration d'image médicale
// =========================================================================
function process_image_module() // Ancien traitement_image_medicale
    global app_state;
    
    disp('Debut traitement image...');
    
    try
        // Récupérer les paramètres du module 'image'
        module_config = app_state.modules.image;
        parameters = module_config.default_params; // p
        
        // Génération image synthétique
        [original_image, noisy_image] = generate_test_image(parameters); // img_orig, img_bruite
        
        // Traitement
        denoised_image = apply_median_filter(noisy_image, parameters.median_filter_size); // img_debruit
        sharpened_image = apply_sharpening_filter(denoised_image); // img_accent
        
        // Métriques
        mse_noisy = calculate_mse(original_image, noisy_image); // MSE_bruite
        mse_treated = calculate_mse(original_image, sharpened_image); // MSE_traitee
        
        // Calcul de l'amélioration en pourcentage
        if mse_noisy > 0 then
            improvement_percent = ((mse_noisy - mse_treated) / mse_noisy) * 100; // amelioration
        else
            improvement_percent = 0;
        end
        
        // Affichage
        show_image_results(original_image, noisy_image, denoised_image, sharpened_image);
        
        // Interprétation
        interpretation_text = sprintf('Traitement reussi ! Amelioration de %.1f%% (MSE : %.1f -> %.1f). Le filtre median a elimine le bruit et accentuation a restaure les details.', ...
                        improvement_percent, mse_noisy, mse_treated);
        update_interpretation_zone(interpretation_text);
        
        disp('Traitement image termine.');
        
    catch
        disp('ERREUR dans process_image_module');
        err = lasterror();
        disp('Message : ' + err.message);
        update_interpretation_zone('Erreur lors du traitement image. Voir console.');
    end
endfunction

// --- Fonctions de support (Renommage en Anglais) ---

function [original_image, noisy_image] = generate_test_image(parameters) // generer_image_test
    // Image originale synthétique (carré + cercle)
    rows = 200; // l
    cols = 200; // c
    original_image = zeros(rows, cols);
    original_image(50:150, 80:120) = 1;
    
    // Cercle
    [xx, yy] = ndgrid(1:rows, 1:cols);
    center = [100, 100];
    radius = 30;
    mask = ((xx - center(1)).^2 + (yy - center(2)).^2) <= radius^2;
    original_image(mask) = 1;
    original_image = uint8(original_image * 255); // Convertir en 0-255
    
    // Flou gaussien
    blur_sigma = parameters.blur_sigma;
    kernel_size = 2 * ceil(3 * blur_sigma) + 1; // taille_noyau
    x_lin = linspace(-(kernel_size-1)/2, (kernel_size-1)/2, kernel_size);
    gaussian_kernel = exp(-(x_lin.^2) / (2 * blur_sigma^2)); // noyau_gauss
    gaussian_kernel = gaussian_kernel' * gaussian_kernel;
    gaussian_kernel = gaussian_kernel / sum(gaussian_kernel);
    
    blurred_image = conv2(double(original_image), gaussian_kernel, 'same'); // img_floue
    blurred_image = uint8(blurred_image);
    
    // Bruit poivre et sel (Salt and Pepper Noise)
    // Note: parameters.noise_level_factor est entre 0 et 1 (e.g., 0.05 pour 5%)
    noisy_image = double(blurred_image);
    noise_mask = rand(size(blurred_image)) < parameters.noise_level_factor; // masque_bruit
    
    // Assigner des valeurs aléatoires (0 ou 255) aux pixels bruités
    % Pour Scilab, rand() sans argument donne un double entre 0 et 1.
    % Multiplier par 255 donne une valeur entre 0 et 255.
    
    % On simule poivre et sel en mettant 50% des pixels bruités à 0 et 50% à 255
    num_noisy_pixels = sum(noise_mask);
    
    if num_noisy_pixels > 0 then
        salt_pixels_count = floor(num_noisy_pixels / 2);
        
        % Trouver les indices des pixels bruités
        [row_indices, col_indices] = find(noise_mask);
        
        % Mélanger et sélectionner les indices pour le sel (255) et le poivre (0)
        rand_order = randperm(num_noisy_pixels);
        
        salt_indices = rand_order(1:salt_pixels_count);
        pepper_indices = rand_order(salt_pixels_count+1:end);
        
        % Appliquer le bruit
        for k = 1:length(salt_indices)
            noisy_image(row_indices(salt_indices(k)), col_indices(salt_indices(k))) = 255;
        end
        for k = 1:length(pepper_indices)
            noisy_image(row_indices(pepper_indices(k)), col_indices(pepper_indices(k))) = 0;
        end
    end

    noisy_image = uint8(noisy_image);
endfunction

function output_image = apply_median_filter(input_image, size) // appliquer_filtre_median_image
    [rows, cols] = size(input_image); // l, c
    output_image = input_image;
    half_size = floor(size/2); // demi
    
    // Conversion en double pour les calculs de voisinage
    double_input = double(input_image);
    
    for i = (1+half_size):(rows-half_size)
        for j = (1+half_size):(cols-half_size)
            // Extraire le voisinage
            neighborhood = double_input(i-half_size:i+half_size, j-half_size:j+half_size); // voisinage
            // Calculer la médiane et réaffecter
            output_image(i, j) = median(neighborhood(:));
        end
    end
endfunction

function output_image = apply_sharpening_filter(input_image) // appliquer_accentuation_image
    sharpen_mask = [0, -1, 0; -1, 5, -1; 0, -1, 0]; // masque_sharpen (Laplacien)
    
    % Utilisation de conv2 pour la convolution
    output_image = conv2(double(input_image), sharpen_mask, 'same');
    
    % Tronquage et conversion en uint8
    output_image = uint8(max(0, min(255, output_image)));
endfunction

function mse = calculate_mse(img1, img2) // calculer_mse (supposé dans utils)
    // Mean Squared Error (Erreur Quadratique Moyenne)
    diff_img = double(img1) - double(img2);
    mse = mean(diff_img.^2);
endfunction
