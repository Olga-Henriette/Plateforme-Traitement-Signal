// =========================================================================
// PROCESS_RADAR.SCI - Estimation de distance par corrélation croisée
// =========================================================================
function process_radar_module() // Ancien traitement_radar
    global app_state;
    
    disp('Debut traitement Radar...');
    
    try
        // Récupérer les paramètres du module 'radar'
        module_config = app_state.modules.radar;
        parameters = module_config.default_params;
        
        // Constantes physiques
        speed_of_light = 3e8; // c
        
        // Configuration
        sampling_frequency = 10000; // fe
        sampling_period = 1/sampling_frequency; // Te
        duration_s = 0.05; // Durée du chirp (fixe)
        
        // Vecteur temps
        time_vector = 0:sampling_period:(duration_s - sampling_period); // t
        
        disp('Generation signal emis (Chirp)...');
        // Generation du signal émis (Chirp LFM)
        transmitted_signal = generate_chirp(time_vector, parameters.chirp_start_freq_hz, parameters.chirp_end_freq_hz, duration_s); // signal_emis
        
        // Calculer le retard théorique (Time Delay)
        target_distance = parameters.target_distance_m; // distance_cible
        time_delay_theo = 2 * target_distance / speed_of_light; // retard_theo
        
        disp(sprintf('Distance cible : %.0f m. Retard theorique : %.2e s.', target_distance, time_delay_theo));
        
        disp('Simulation canal et bruit...');
        // Simulation du signal reçu
        received_signal = simulate_radar_reception(transmitted_signal, sampling_frequency, time_delay_theo); // signal_recu
        
        // Ajout du bruit
        received_signal_noisy = add_gaussian_noise(received_signal, parameters.snr_db); // signal_recu_bruite
        
        disp('Corrélation croisée pour estimation du retard...');
        // Corrélation croisée
        [correlation_vector, lag_vector] = calculate_cross_correlation(transmitted_signal, received_signal_noisy, sampling_frequency); // correlation, lag
        
        // Estimation du retard
        [max_corr, max_index] = find_maximum(correlation_vector); // trouver_maximum (supposé dans utils)
        estimated_delay = lag_vector(max_index); // retard_estime
        
        // Estimation de la distance
        estimated_distance = estimated_delay * speed_of_light / 2; // distance_estimee
        
        // Erreur d'estimation
        estimation_error = abs(estimated_distance - target_distance); // erreur_estimation
        
        disp('Affichage resultats...');
        // Affichage
        show_radar_results(time_vector, transmitted_signal, received_signal_noisy, lag_vector, correlation_vector, estimated_delay, estimated_distance);
        
        // Interpretation
        interpretation_text = sprintf('Estimation reussie ! Distance estimee : %.1f m. Retard : %.2e s. Erreur d''estimation : %.1f m.', ...
                        estimated_distance, estimated_delay, estimation_error);
        
        update_interpretation_zone(interpretation_text);
        
        disp('Traitement Radar termine.');
        
    catch
        disp('ERREUR dans process_radar_module');
        err = lasterror();
        disp('Message : ' + err.message);
        update_interpretation_zone('Erreur lors du traitement radar. Voir console.');
    end
endfunction

// --- Fonctions de support (Renommage en Anglais) ---

function chirp_signal = generate_chirp(time_vector, f_start, f_end, duration_s) // generer_chirp
    % Chirp LFM (Linear Frequency Modulation)
    bandwidth = f_end - f_start; // B
    slope = bandwidth / duration_s; // K
    phase = 2 * %pi * (f_start * time_vector + 0.5 * slope * time_vector.^2);
    chirp_signal = cos(phase);
endfunction

function received_signal = simulate_radar_reception(transmitted_signal, sampling_frequency, time_delay) // simuler_reception_radar
    // Simulation du retard et de l'atténuation
    
    // Calcul du décalage en échantillons
    delay_samples = round(time_delay * sampling_frequency); // decalage_echantillons
    
    if delay_samples < 0 then delay_samples = 0; end
    
    N = length(transmitted_signal);
    received_signal = zeros(1, N);
    
    % Atténuation simple (pour ne pas saturer la corrélation)
    attenuation_factor = 0.5; // facteur_attenuation
    
    // Décalage du signal
    if delay_samples < N then
        received_signal(delay_samples + 1:N) = attenuation_factor * transmitted_signal(1:N - delay_samples);
    end
endfunction

function noisy_signal = add_gaussian_noise(input_signal, snr_db) // ajouter_bruit_gaussien
    % Ajoute du bruit gaussien pour atteindre un SNR cible (en dB)
    
    signal_power = mean(input_signal.^2); // puissance_signal
    
    if signal_power > 1e-10 then
        % Calcul de la puissance du bruit
        noise_power = signal_power / (10^(snr_db/10)); // puissance_bruit
    else
        noise_power = 0.01;
    end
    
    noise = sqrt(noise_power) * rand(1, length(input_signal), 'normal'); // bruit
    noisy_signal = input_signal + noise;
endfunction

function [correlation_vector, lag_vector] = calculate_cross_correlation(signal1, signal2, sampling_frequency) // calculer_intercorrelation
    // Utilisation de Scilab pour la corrélation croisée (xcorr)
    
    [correlation_vector, lag_index] = xcorr(signal1, signal2); // corr_vec, lag_index
    
    // Conversion de l'index de retard en temps (secondes)
    lag_vector = lag_index / sampling_frequency; // lag_vec_temps
endfunction
